# Prompt Loop State Protocol (PLSP) Specification v0.5 (Human-Readable)

**Version:** 0.5
**Date:** April 7, 2025
**Status:** Draft - Optimized for Bidirectional Machine Communication

## 1. Overview

Prompt Loop State Protocol (PLSP) v0.5 defines an **ultra-minimal, token-efficient syntax** ecosystem for managing stateful operations within a Large Language Model (LLM), orchestrated by an external **Middleware** component. This version assumes a tight loop where both the instructions sent *to* the LLM and the state block sent *from* the LLM are highly compressed and designed **exclusively for machine interpretation**. Human readability is sacrificed for maximum efficiency in token count and processing load.

**Design Goals:**
*   **Extreme Token Efficiency:** Minimize tokens for both LLM state (`S{...}S`) and Middleware instructions (`INSTR:`), primarily using single-character variables (`$a`, `$b`...) and compressed directives.
*   **Minimal LLM Compute Load:** Offload complex logic, external actions (I/O, delays, alerts), and instruction generation to the Middleware. The LLM functions primarily as a fast, symbolic state transformation engine.
*   **Middleware Orchestration:** The Middleware drives the loop, handles external interactions, manages timing, and translates high-level goals into compressed instructions for the LLM.
*   **Machine-Only Debugging:** The `INSTR:` and `S{...}S` blocks are the primary artifacts for debugging, expected to be parsed and analyzed by automated tools or developers at the Middleware level.
*   **Self-Contained State:** Each `S{...}S` block generated by the LLM MUST contain *all* necessary state to continue execution, assuming prior turn history might be lost.

## 2. Core Concept: The Bidirectional Machine Loop

PLSP v0.5 operates in a strict cycle orchestrated by the Middleware:

1.  **Middleware -> LLM (Instruction Phase):**
    *   The Middleware prepares a compressed instruction string, formatted according to an agreed-upon **Instruction Micro-Format (IMF)**, prefixed typically by `INSTR:`. Examples: `INSTR: @set:$p="run"; @upd:$t=val; @if:cond? then:else; @sig:!act;`. The specific IMF syntax is flexible and defined by the Middleware implementation, relying on the LLM's ability to parse it based on context or fine-tuning.
    *   The Middleware sends this `INSTR:` string along with the `Previous S{...}S` block (the complete state block generated by the LLM in the last cycle, or `S{}S` if first cycle) to the LLM.

2.  **LLM -> LLM (Processing Phase):**
    *   The LLM parses the `INSTR:` directives.
    *   Using the `Previous S{...}S` as context, it executes the logic defined by the directives. This involves calculating state changes (variable updates like `$a:newValue;`), determining if any data needs logging (`> data;`), and identifying if any actions need signaling to the Middleware (`!action;`). Tool usage (like internal search or code execution) might be implicitly triggered by specific `INSTR:` directives, with results incorporated into the state update.
    *   The LLM constructs the `Next S{...}S` block, containing the *complete, updated state* including all variable assignments and any generated `>` or `!` commands.

3.  **LLM -> Middleware (Response Phase):**
    *   The LLM outputs **ONLY** the newly generated `Next S{...}S` block. It does *not* produce conversational filler or other natural language output unless specifically instructed via a `>` command meant for logging.

4.  **Middleware -> Middleware (Post-Processing Phase):**
    *   The Middleware receives and parses the `Next S{...}S` block from the LLM.
    *   It extracts and executes any `!` action commands (e.g., `!wait,5000` -> pause 5s; `!page,"msg"` -> send alert; `!fetch,src` -> get external data).
    *   It extracts and processes any `>` log/data commands (e.g., display on a dashboard, write to a log file).
    *   Based on the results of executed actions, new external data, and the state variables within the received `S{...}S` block, the Middleware prepares the `INSTR:` directive string for the *next* cycle (back to step 1).

## 3. Instruction Micro-Format (IMF) (`INSTR:`)

*   **Purpose:** To provide compressed, machine-parseable instructions from the Middleware to the LLM.
*   **Syntax:** Not rigidly defined by PLSP itself. It's an agreement between the Middleware implementation and the LLM's expected parsing capabilities (trained via examples or context in the system prompt).
*   **Characteristics:** Typically uses symbolic prefixes (`@`, `#`, etc.) or short keywords, key-value pairs, and potentially simple conditional logic representation.
*   **Example Structures (Illustrative):**
    *   `@set:$var=value;` - Direct variable assignment.
    *   `@upd:$var=value;` - Update existing variable (might imply reading first).
    *   `@fetch:source,$destVar;` - Implies LLM tool use to get data from `source` and store in `$destVar`.
    *   `@if:condition? true_directives : false_directives;` - Conditional execution logic.
    *   `@sig:!action,param;` - Instruct LLM to include a specific `!` command in its output state.
*   **Parsing:** The LLM must be guided (via system prompt, examples) on how to interpret the specific IMF used by the Middleware.

## 4. PLSP `S{...}S` Syntax Details (v0.5 - LLM Output)

This defines the structure of the block generated *by the LLM*.

### 4.1. State Block (`S{...}S`)

*   All LLM-generated state/commands enclosed within `S{` and `}S`.
*   Example: `S{$p:"run";$t:75;$l:70;!wait,5000;}S`

### 4.2. Statements

*   Units separated by semicolon (`;`).
*   Whitespace generally ignored *except* within strings. Minimal use preferred.
*   **No Comments (`#`) allowed.**

### 4.3. Variable Assignment (`$id:val;`)

*   Stores/updates state.
*   **Identifier (`$id`): Strongly PREFER single characters `$[a-zA-Z]`** for max token efficiency (52 unique vars: `$a`..`$z`, `$A`..`$Z`).
    *   *Extension:* Use `$[a-zA-Z0-9]` (`$a1`, `$x9`) only if single characters are insufficient and the performance trade-off is acceptable. Clear instructions are needed to manage extended use.
*   Assignment uses colon (`:`).
*   Value (`val`): String literal (`"..."`), Number literal (`num`), or Variable Reference (`$id`).
*   Example: `S{$i:"user_input";$c:10;$r:$i;}S`

### 4.4. Data Types

*   **String (`"..."`):** Double quotes. Literal characters. No standard escapes. Example: `"OK"`, `"T:$t"` ($t is literal).
*   **Number (`digits[.digits]`):** Unquoted numerals. Example: `100`, `3.14`.

### 4.5. Log/Output Data Command (`>val1,val2,...;`)

*   Signals data points intended for the **Middleware** to log, display, or otherwise process.
*   Starts with `>`. Followed by comma-separated values (Literals or `$id` references).
*   This does **not** typically result in direct LLM chat output visible to an end-user, but rather structured data passed back to the orchestrator.
*   Example: `S{$t:75; >"Temp OK",$t;}S` -> Middleware receives the value 75 via the `>` command.

### 4.6. Action Command (`!act,p1,p2,...;`)

*   Signals a specific action request for the **Middleware** to execute.
*   Starts with `!`. Followed by an `action_identifier` (e.g., `wait`, `page`, `fetch`) and optional comma-separated parameters (Literals or `$id` references).
*   The Middleware intercepts these, performs the corresponding external action, and may use the result to influence the next `INSTR:`.
*   Example: `S{$u:"op";$m:"CPU High"; !page,$u,$m; !wait,1000;}S` -> Middleware should page operator 'op' with message "CPU High", then wait 1 second.

## 5. State Management

*   **CRITICAL:** The `S{...}S` block generated by the LLM **MUST contain the ENTIRE state** (all `$a`, `$b`... variables with current values) required for the next cycle.
*   **Carry-Forward:** If logic requires comparing current values to previous ones (e.g., anomaly detection), the previous value MUST be explicitly stored in a separate variable (e.g., `$l` for last value) and included in the state block each turn.
*   **History Loss:** Assume only the most recent `S{...}S` block and the incoming `INSTR:` are available to the LLM.

## 6. Tool Integration (Implicit)

*   LLM's internal tools (search, calculation) are triggered based on interpreting specific `INSTR:` directives (e.g., `@fetch:source,$destVar;`).
*   The LLM uses the tool internally and incorporates the result directly into the `Next S{...}S` block via a standard variable assignment (`$destVar:result;`).

## 7. Debugging

*   Debugging primarily occurs at the **Middleware level**.
*   It involves inspecting the sequence of:
    1.  `INSTR:` generated by the Middleware.
    2.  `Previous S{...}S` sent to the LLM.
    3.  `Next S{...}S` received back from the LLM.
*   Analyzing this flow allows developers to verify state transitions, check if `!` actions were correctly signaled, and ensure `>` data is appropriate. The machine-focused syntax aids automated parsing and analysis during debugging.

## --- End of Specification ---