**1. Hyper-Compressed PLSP v0.5 Specification (for LLM Instruction)**

```text
PLSPv0.5 SPEC: LLM INTERNAL. GOAL: MIN TOKEN/CPU STATE+ACT for LLM<->MidWare LOOP. THIS=YOUR CORE LOGIC.
EXEC LOOP: 1.MW->LLM: Send `INSTR:<directives>;` + `Prev S{..}S`. 2.LLM PROC: Parse `INSTR`, exec logic w/ `S{..}S` ctx. Calc stateΔ(`$l:v`), ACT(`!`), log/out(`>`). 3.LLM->MW: Output *ONLY* NEW `Next S{..}S` (COMPLETE state+cmds). 4.MW POST: Parse `Next S{..}S`. Execute `!` cmds (wait, page, fetch); Handle `>` data; Prep next `INSTR`.
INSTR FMT (EXAMPLE): `@k:v; @upd:$id=val; @if:cond? then_cmds : else_cmds; @sig:!act,p; @set:$id=val;`. LLM MUST parse `INSTR` based on prompt context/examples.
PLSP SYNTAX (`S{..}S` block): BLK:`S{stmts}S`. STMT sep:`;`. ASN:`$id:v;`. ID:`$[a-zA-Z]` PREF(52); extend `$a1` IF NEEDED. `v`=VAL(STR|NUM|$id). STR:`"lit"`. NUM:`d[.d]`. LOG/OUT:`>v1,..;` (MW handles). ACTION:`!act,p1,..;` (MW execs). NO CMT/#. Ignore space ex STR.
STATE: `Next S{..}S` MUST CONTAIN ALL needed state (`$p`=purpose, `$l`=last_val, etc). History outside last `S{..}S` LOST.
TOOL USE (Implicit): `INSTR` directives may imply tool use (e.g., `@fetch:src,$dest_var;`). LLM uses tool, stores result via ASN in `Next S{..}S`.
DEBUG: Structure targets machine parseability for MW debugging.
END SPEC.
```

**Key Changes in v0.5 Compressed Spec:**

* **EXEC LOOP:** Clarified the cycle: MW->LLM (INSTR + Prev S), LLM PROC, LLM->MW (Next S), MW POST (Parse S, Exec !, Prep next INSTR). Explicitly states LLM outputs only S{...}S.
* **INSTR FMT:** Introduced the concept of a compressed `INSTR:<directives>;` format generated by the middleware, providing abstract examples (`@k:v`, `@upd`, `@if`, `@sig`, `@set`). Emphasized LLM parsing relies on context/examples.
* **PLSP SYNTAX:** Renamed OUT_CMD to LOG/OUT (`>`) to clarify its primary role is data for middleware logging/display, not direct LLM chat output. Renamed ACT_CMD to ACTION (`!`).
* **TOOL USE:** Clarified tool use is triggered via INSTR directives.
* **DEBUG:** Added note about targeting machine parseability for middleware debugging.

**2. PLSP v0.5 EBNF Grammar**
(The EBNF describes the structure of the S{...}S block generated by the LLM. It does not describe the `INSTR:` format, which is handled implicitly by the LLM based on instructions/examples.)

```Ebnf
(* PLSP v0.5 EBNF Grammar - Defines structure of S{...}S block *)

plsp_block       = "S{" , [ statements ] , "}S" ;

statements       = statement , { ";" , statement } , [";"] ;

statement        = assignment | log_output_command | action_command ;

assignment       = variable_identifier , ":" , value ;

log_output_command = ">" , value_list ; (* Data for Middleware logging/display *)

action_command   = "!" , action_identifier , [ "," , value_list ] ; (* Signals for Middleware execution *)

action_identifier= ? regex /[a-zA-Z][a-zA-Z0-9_]*/ ? ; (* e.g., page, wait, fetch_sensors *)

value_list       = value , { "," , value } ;

value            = string_literal | number_literal | variable_reference ;

variable_reference = variable_identifier ;

(* Identifier Rule: Prioritize single letters *)
variable_identifier = "$" , ( single_letter_id | extended_id ) ;
single_letter_id = ? regex /[a-zA-Z]/ ? ;
extended_id      = ? regex /[a-zA-Z_][a-zA-Z0-9_]*/ ? ; (* Fallback/Extension *)

string_literal   = '"' , { ? character excluding '"' ? } , '"' ;

number_literal   = ? regex /[0-9]+(\.[0-9]+)?/ ? ;

(* Whitespace flexible except in string_literal *)
```

**EBNF Change:** Renamed `output_command` to `log_output_command` to match spec terminology.

**3. Example Programs README (v0.5 - Reflecting Middleware Focus)**
# **PLSP v0.5 Advanced Examples README (Middleware Interaction Focus)**

This README shows PLSP v0.5 usage, emphasizing the LLM's role as a state machine driven by compressed **Instructions (`INSTR:`)** from Middleware and outputting purely machine-parseable **State Blocks (`S{...}S`)** containing state updates, data logs (`>`), and action signals (`!`) for the Middleware.

**Key v0.5 Aspects:**
* **LLM Input:** Compressed `INSTR:<directives>;` + `Previous S{...}S`.
* **LLM Output:** *Only* the `Next S{...}S` block.
* **Middleware Role:** Parses `S{...}S`, executes `!` actions (wait, page), handles `>` data, fetches external info, generates next `INSTR:`.
* **Machine-Only:** Both `INSTR:` and `S{...}S` are optimized for machine parsing (low token, simple structure). Debugging happens at the Middleware level by inspecting these blocks.

**LLM System Prompt (includes v0.5 spec):**
(Precedes every `INSTR:` / `S{...}S` input pair)
```text
SYSTEM: You are PLSP v0.5 Executor. Follow ONLY these rules:
PLSPv0.5 SPEC: LLM INTERNAL. GOAL: MIN TOKEN/CPU STATE+ACT for LLM<->MidWare LOOP. THIS=YOUR CORE LOGIC.
EXEC LOOP: 1.MW->LLM: Send `INSTR:<directives>;` + `Prev S{..}S`. 2.LLM PROC: Parse `INSTR`, exec logic w/ `S{..}S` ctx. Calc stateΔ(`$l:v`), ACT(`!`), log/out(`>`). 3.LLM->MW: Output *ONLY* NEW `Next S{..}S` (COMPLETE state+cmds). 4.MW POST: Parse `Next S{..}S`. Execute `!` cmds (wait, page, fetch); Handle `>` data; Prep next `INSTR`.
INSTR FMT (EXAMPLE): `@k:v; @upd:$id=val; @if:cond? then_cmds : else_cmds; @sig:!act,p; @set:$id=val;`. LLM MUST parse `INSTR` based on prompt context/examples.
PLSP SYNTAX (`S{..}S` block): BLK:`S{stmts}S`. STMT sep:`;`. ASN:`$id:v;`. ID:`$[a-zA-Z]` PREF(52); extend `$a1` IF NEEDED. `v`=VAL(STR|NUM|$id). STR:`"lit"`. NUM:`d[.d]`. LOG/OUT:`>v1,..;` (MW handles). ACTION:`!act,p1,..;` (MW execs). NO CMT/#. Ignore space ex STR.
STATE: `Next S{..}S` MUST CONTAIN ALL needed state (`$p`=purpose, `$l`=last_val, etc). History outside last `S{..}S` LOST.
TOOL USE (Implicit): `INSTR` directives may imply tool use (e.g., `@fetch:src,$dest_var;`). LLM uses tool, stores result via ASN in `Next S{..}S`.
DEBUG: Structure targets machine parseability for MW debugging.
END SPEC.
Process the `INSTR:` directives using the `Previous S{...}S` state. Output ONLY the complete `Next S{...}S` block reflecting all state changes and action/log signals.
```

**Example 1: Server Monitor (v0.5 - Compressed Instructions)**
**Goal:** Monitor temperature (`$t`), alert (`!page`) if jump > 10 from last (`$l`), wait 5s (`!wait`).
**Interaction (LLM Input/Output focused):**

**Cycle 1 (Init)**
**Middleware Generates:** `INSTR: @init; @set:$p="monitor"; @set:$t=70; @set:$l=70; @sig:!wait,5000;`
**LLM Input:**
```text
INSTR: @init; @set:$p="monitor"; @set:$t=70; @set:$l=70; @sig:!wait,5000;
Previous S{...}S: S{}S
```

**LLM Output (Next S{...}S):**
```text
S{$p:"monitor";$t:70;$l:70;!wait,5000;}S
```
**Middleware Parses/Acts:** Extracts `!wait,5000;`. Pauses 5s. Fetches Temp=75.

**Cycle 2 (Normal)**

**Middleware Generates:** `INSTR: @sensor_in:t=75; @upd:$t; @if:$t>$l+10?(@set:$p="alert"; @sig:!page,"High",$t):(@set:$l=$t); @set:$p="monitor"; @sig:!wait,5000;`
**LLM Input:**
```text
INSTR: @sensor_in:t=75; @upd:$t; @if:$t>$l+10?(@set:$p="alert"; @sig:!page,"High",$t):(@set:$l=$t); @set:$p="monitor"; @sig:!wait,5000;
Previous S{...}S: S{$p:"monitor";$t:70;$l:70;!wait,5000;}S
```

**LLM Output (Next S{...}S):**
```text
S{$p:"monitor";$t:75;$l:75;!wait,5000;}S
```
**Middleware Parses/Acts:** Compares 75 vs 70+10 (false). Sees `!wait,5000`. Pauses 5s. Fetches Temp=92.

**Cycle 3 (Anomaly)**

**Middleware Generates:** `INSTR: @sensor_in:t=92; @upd:$t; @if:$t>$l+10?(@set:$p="alert"; @sig:!page,"High",$t):(@set:$l=$t); @set:$p="monitor"; @sig:!wait,5000;`
**LLM Input:**
```text
INSTR: @sensor_in:t=92; @upd:$t; @if:$t>$l+10?(@set:$p="alert"; @sig:!page,"High",$t):(@set:$l=$t); @set:$p="monitor"; @sig:!wait,5000;
Previous S{...}S: S{$p:"monitor";$t:75;$l:75;!wait,5000;}S
```

**LLM Output (Next S{...}S):**
```text
S{$p:"alert";$t:92;$l:75;!page,"Temp High",92;!wait,5000;}S
```
**Middleware Parses/Acts:** Compares 92 vs 75+10 (true). Executes `!page,"Temp High",92;`. Then executes `!wait,5000;`. Pauses 5s. Fetches Temp=80.

**Cycle 4 (Recovery)**

**Middleware Generates:** `INSTR: @ctx:alerted; @sensor_in:t=80; @upd:$t; @if:$t>$l+10?(@set:$p="alert_ongoing"; @sig:!page,"Still High",$t):(@set:$l=$t); @set:$p="monitor"; @sig:!wait,5000;`
**LLM Input:**
```text
INSTR: @ctx:alerted; @sensor_in:t=80; @upd:$t; @if:$t>$l+10?(@set:$p="alert_ongoing"; @sig:!page,"Still High",$t):(@set:$l=$t); @set:$p="monitor"; @sig:!wait,5000;
Previous S{...}S: S{$p:"alert";$t:92;$l:75;!page,"Temp High",92;!wait,5000;}S
```

**LLM Output (Next S{...}S):**
```text
S{$p:"monitor";$t:80;$l:80;!wait,5000;}S
```
**Middleware Parses/Acts:** Compares 80 vs 75+10 (false). State normalizes. Sees `!wait,5000;`. Pauses 5s. Continues loop.

**Human-Readable Explanation Notes (Focus on Flow):**

* The Middleware is now the primary "programmer". It crafts the compressed `INSTR:` based on external data and the logic it wants the LLM to execute.
* The LLM acts as a pure state calculation engine. It reads the instruction, reads the previous state, calculates the entirety of the next state (including variables and any `!` or `>` commands implied by the instruction), and outputs only that new state block.
* The Middleware then decomposes the `S{...}S` block:
    * It handles side effects (`!` commands).
    * It logs or uses data from `>` commands.
    * It uses the variable values (`$p`, `$t`, `$l`) to inform the next `INSTR:` it generates.
* This minimizes the LLM's work to pure state transformation based on symbolic input, maximizing efficiency and leveraging the Middleware for external actions and complex instruction generation. Debugging involves examining the `INSTR:` generated by Middleware and the resulting `S{...}S` from the LLM at each cycle.

