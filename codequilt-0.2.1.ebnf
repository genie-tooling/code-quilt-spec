(* --- CodeQuilt v0.2.0 EBNF --- *)
(* Based on Specification dated 2025-04-06 *)

(* -------- Top Level -------- *)
codequilt-string ::= "[" header "]" "|||" body-tokens

(* -------- Header -------- *)
(* Key-value pairs separated by semicolons. Order generally not significant, *)
(* but all required fields for the chosen verbosity level MUST be present. *)
header ::= header-field (";" header-field)*

header-field ::= version-field
               | language-field
               | dict-field
               | imports-field   (* Optional, Level 2+ *)
               | options-field   (* Optional, Level 2+ *)
               | checksum-field  (* Optional, Level 2+ *)
               | lit-dict-field  (* Optional, Level 3 Only *)

version-field  ::= "v:" version-string
language-field ::= "lang:" language-id ("-" language-version)?
dict-field     ::= "dict:" "[" (dict-entry ("," dict-entry)*)? "]"
imports-field  ::= "imports:" "[" (import-item ("," import-item)*)? "]"
options-field  ::= "opts:" "[" (option ("," option)*)? "]"
checksum-field ::= "chk:" checksum-algo "-" checksum-hash
lit-dict-field ::= "lit_dict:" "[" (lit-dict-entry ("," lit-dict-entry)*)? "]"

(* -------- Header Components -------- *)
version-string   ::= digit+ "." digit+ "." digit+        (* e.g., 0.2.0 *)
language-id      ::= identifier                         (* e.g., python, javascript, c++ *)
language-version ::= language-version-char+             (* e.g., 3.11, es2022, c++17, 11 *)

dict-entry       ::= "d" digit+ "=" identifier          (* e.g., d0=myVar *)
import-item      ::= import-path (" " "as" " " identifier)? (* e.g., my_module, pandas as pd *)
import-path      ::= safe-header-value-char+            (* Chars safe for header values, excluding ',' *)
option           ::= identifier ("=" option-value)?     (* e.g., strict, fmt=on *)
option-value     ::= safe-header-value-char+            (* Chars safe for header values, excluding ',' *)
checksum-algo    ::= identifier                         (* e.g., sha256 *)
checksum-hash    ::= hex-digit+                         (* e.g., a1b2c3d4... *)
lit-dict-entry   ::= "l" digit+ "=" base64-string       (* e.g., l0=VGhpcyBpcyB... *)

(* -------- Body -------- *)
(* Sequence of tokens. Whitespace CHARACTERS between tokens are ignored by the *)
(* reconstructor, except when part of a string-literal token's content. *)
body-tokens ::= (token)*

token ::= structure-token
        | keyword-token     (* Actual set depends on header 'lang' *)
        | operator-token    (* Actual set depends on header 'lang' *)
        | delimiter-token   (* Actual set depends on header 'lang' *)
        | literal-token
        | identifier-ref
        | literal-ref
        | comment-token     (* For short, inline comments *)
        | preprocessor-token(* Actual set/args depend on header 'lang', e.g., C/C++ *)
        | escape-hatch-token
        | decorator-prefix  (* Actual presence/use depends on header 'lang', e.g., Python *)

(* -------- Body Token Types (Based on Spec Examples & ยง4/ยง5) -------- *)
(* Note: Keyword, Operator, Delimiter, Preprocessor sets are illustrative and language-dependent *)
structure-token   ::= "N" | "I+" | "I-" | "{" | "}"
keyword-token     ::= "D" | "C" | "R" | "?" | ":" | "F" | "W" | "T" | "X" | "Y" | "M" | "A" | "S" | "P" (* etc. *)
operator-token    ::= "=" | "+" | "-" | "*" | "/" | "%" | "**" | "&" | "|" | "~" | "!" | ">" | "<" | "G" | "L" | "E" | "." (* etc. *)
delimiter-token   ::= "(" | ")" | "[" | "]" | "," | ";" | ":" (* ':' use is contextual *)
literal-token     ::= string-literal | number-literal | boolean-literal | null-literal | bytes-literal
identifier-ref    ::= "d" digit+
literal-ref       ::= "l" digit+
comment-token     ::= ("//" | "#") string-literal        (* Assumes comment *content* follows string literal rules *)
                    | "/*" string-literal "*/"        (* Assumes comment *content* follows string literal rules *)
preprocessor-token::= "#i" | "#d" | "#?" | "#e" | "#p" | "#:" (* Followed by language-specific args not fully defined here, e.g., '<vector>' or 'MAX 100' *)
escape-hatch-token::= "L" "'{" raw-host-code "}'"
decorator-prefix  ::= "@"

(* -------- Literal Token Details -------- *)
string-literal ::= "'" (single-quoted-string-char)* "'"
                 | '"' (double-quoted-string-char)* '"'
number-literal ::= ("+" | "-")? digit+ ("." digit+)? (* Simplified per spec *)
boolean-literal::= "t" | "f"
null-literal   ::= "n"
bytes-literal  ::= "b" string-literal              (* e.g., b'abc', b"def" *)

(* -------- Escape Hatch Content -------- *)
raw-host-code ::= (raw-host-char)*
raw-host-char ::= escaped-brace | non-brace-non-backslash-char
escaped-brace ::= "\\" ("{" | "}")

(* -------- Basic Definitions / Character Sets -------- *)
identifier      ::= letter (letter | digit | "_")*
base64-string   ::= (base64-char)* ("=" "="?)?
base64-char     ::= letter | digit | "+" | "/"
version-string  ::= digit+ "." digit+ "." digit+
hex-digit       ::= digit | "a".."f" | "A".."F"

(* --- Character Sets & Terminal Primitives --- *)
(* Note: Defining exact character sets allowed WITHIN strings or header values formally *)
(* in EBNF is complex. We define what's explicitly disallowed or explicitly allowed. *)
(* A real implementation relies heavily on the lexical analyzer. *)

letter                      ::= "a".."z" | "A".."Z"
digit                       ::= "0".."9"
language-version-char       ::= letter | digit | "+" | "." (* Chars allowed in lang version *)
safe-header-value-char      ::= letter | digit | "_" | "." | "/" | "+" | ":" | "-" | "=" (* Printable ASCII assumed, EXCLUDING '[', ']', ';', ',' and whitespace not part of the value itself *)
                                (* This is an approximation; spec implies no whitespace *around* delimiters, *)
                                (* but values *might* contain spaces if carefully handled/quoted, though discouraged. *)
                                (* Base64 in lit_dict avoids this issue for complex values. *)

(* Characters within standard string literals: *)
single-quoted-string-char ::= escape-sequence | non-apostrophe-non-backslash-char
double-quoted-string-char ::= escape-sequence | non-quote-non-backslash-char
escape-sequence           ::= "\\" ( "'" | '"' | "\\" | "n" | "t" | "r" | "b" | "f" | unicode-escape ) (* common escapes, non-exhaustive *)
unicode-escape            ::= "u" hex-digit hex-digit hex-digit hex-digit (* Example *)

(* Conceptual sets for characters - A Lexer would define these precisely *)
non-apostrophe-non-backslash-char ::= (* Any character that is not "'" or "\" *)
non-quote-non-backslash-char      ::= (* Any character that is not '"' or "\" *)
non-brace-non-backslash-char      ::= (* Any character that is not "{" or "}" or "\" *)
