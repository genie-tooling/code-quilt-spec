# CodeQuilt Specification v0.2.0

**Version:** 0.2.0
**Date:** 2025-04-06
**Status:** Draft

## 1. Introduction & Purpose

CodeQuilt is a specification for representing source code in a highly compressed, text-based format. It is designed to be generated by Large Language Models (LLMs) *prior* to generating the full source code. Its primary purpose is to serve as a robust "blueprint" or "manifest" that is less likely to be truncated during generation and can be used to reconstruct the original intended code accurately.

This specification defines the format structure, encoding rules, canonical handling for common and complex language features, fallback mechanisms, and considerations for embedded languages.

## 2. Overall Format

A CodeQuilt string consists of two parts separated by the delimiter `|||`:

```
[Header]|||[Body]
```

* **Header:** Contains metadata, including version, language, identifier/literal mappings, and options. Enclosed in square brackets `[]`.
* **Body:** Contains the compressed sequence of tokens representing the code structure and logic.

## 3. Header Specification (`[Header]`)

The header uses key-value pairs separated by semicolons `;`. Keys are short mnemonics. No whitespace should exist around keys, values, `:`, or `;` unless part of a literal value (which is strongly discouraged; see `lit_dict`).

### 3.1. Header Verbosity Levels

CodeQuilt v0.2.0 defines three distinct header verbosity levels to balance compression with information richness:

* **Level 1 (Shortest):** Minimal required information for basic reconstruction.
* **Level 2 (Medium):** Includes Level 1 plus recommended optional fields for better context and verification.
* **Level 3 (Longest):** Includes Level 2 plus mappings for long literals/comments/embedded code via `lit_dict`. This level is recommended when the source contains significant multi-line strings, comments, or embedded code blocks (HTML, SQL, etc.).

### 3.2. Header Fields

Fields are categorized by the minimum verbosity level at which they MUST appear. Higher levels include all fields from lower levels.

**Level 1 Fields (Required Minimum):**

* `v:<version>`: **(Required)** CodeQuilt specification version (e.g., `v:0.2.0`).
* `lang:<language>[-version]` : **(Required)** Target *host* language and optional version (e.g., `lang:python-3.11`, `lang:javascript-es2022`, `lang:c++17`). Crucial for reconstruction context.
* `dict:[d<n>=identifier,...]` : **(Required)** Identifier Dictionary. Maps compact IDs (`d0`, `d1`, ...) to source code identifiers (variable, function, class names, etc.) in the *host* language. IDs MUST be sequential starting from `d0`. Example: `dict:[d0=myVar,d1=calculateValue]`

**Level 2 Fields (Recommended):**

* *All Level 1 Fields*
* `imports:[path1,path2 as alias,...]` : **(Optional but Recommended)** List of modules/libraries imported in the host language. Aids context. Example: `imports:[os,numpy as np]`
* `opts:[opt1,opt2=value,...]` : **(Optional)** Reconstruction options/flags.
    * `strict`: Suggests failing reconstruction on error/ambiguity.
    * `fmt=on/off`: Hint about expecting post-reconstruction formatting.
    * `enc=<encoding>`: Specify source encoding if not default (e.g., `enc=utf8`). Example: `opts:[strict,fmt=on]`
* `chk:<algo>-<hash>` : **(Optional but Recommended)** Checksum of the intended *final* code for verification. Example: `chk:sha256-a1b2...`

**Level 3 Fields (Maximum Verbosity):**

* *All Level 2 Fields*
* `lit_dict:[l<n>=base64(literal),...]` : **(Optional, Level 3 Specific)** Literal Dictionary. Maps compact IDs (`l0`, `l1`, ...) to long string literals, multi-line comments, docstrings, or `L{}` escape hatch content. **Crucially, this is the primary mechanism for storing embedded code (SQL, HTML, CSS, etc.) that resides within host language strings.** Literals MUST be Base64 encoded to prevent parsing conflicts within the header and ensure accurate reconstruction of potentially complex characters. IDs MUST be sequential starting from `l0`. Example: `lit_dict:[l0=VGhpcyBpcyBhIGRvY3N0cmluZy4=,l1=U0VMRUNUICogRlJPTSB1c2VycyBXSEVSRSBpZCA9IDQyOw==]`

### 3.3. Header Examples

**Level 1 (Shortest):**
```
[v:0.2.0;lang:python-3.11;dict:[d0=my_list,d1=append]]
```

**Level 2 (Medium):**
```
[v:0.2.0;lang:python-3.11;dict:[d0=data,d1=process_data,d2=pd,d3=read_csv];imports:[pandas as pd];opts:[strict];chk:sha256-abcdef12345]
```

**Level 3 (Longest - including Base64'd SQL query):**
```
[v:0.2.0;lang:python-3.11;dict:[d0=db_conn,d1=cursor,d2=execute,d3=user_id];imports:[sqlite3];opts:[strict];chk:sha256-abcdef12345;lit_dict:[l0=IlNFTEVDVCBuYW1lLCBlbWFpbCBGUk9NIHBlb3BsZSBXSEVSRSBpZCA9ID8i]]
```
*(Note: Base64 examples are illustrative)*

## 4. Body Specification (`[Body]`)

The body is a continuous string of tokens representing the code.

### 4.1. Token Philosophy

* **Maximally Dense:** Use single non-alphanumeric characters for common operators/delimiters. Use short mnemonics (typically single uppercase letters) for keywords.
* **Contextual:** Meaning depends on the `lang` specified in the header.
* **No Redundancy:** Omit characters reconstructible from context (e.g., most whitespace).

### 4.2. Whitespace Handling

* Whitespace characters (spaces, tabs, line breaks) within the CodeQuilt **Body** string are **IGNORED**, except when inside a literal string token (e.g., `'...'`).
* Code structure (newlines, indentation) MUST be represented using explicit tokens (`N`, `I+`, `I-`, `{`, `}`).

### 4.3. Canonical Handling of Common & Complex Cases

* **Identifiers:** Represented by `d<n>` tokens, mapping to the `dict` in the header. Applies to host language identifiers.
* **Literals:**
    * Short host language literals directly embedded: `'string'`, `123`, `3.14`, `t` (True), `f` (False), `n` (None/null). Use language-specific prefixes if needed (`b''`, `r''`).
    * Long/Complex literals (docstrings, multi-line comments, **embedded code strings**): Store Base64 encoded content in `lit_dict` (Level 3 Header) and reference with `l<n>` token in the body.
* **Structure:**
    * `N`: Newline.
    * `I+`: Increase indentation level for the *next* line (Pythonic style).
    * `I-`: Decrease indentation level for the *next* line (Pythonic style).
    * `{`: Start of a block. In brace-based languages (`lang:c++`, `lang:javascript`, etc.), this typically implies `I+` for the next line and standard brace placement.
    * `}`: End of a block. In brace-based languages, this typically implies `I-` for the line it appears on (adjusting its own indentation) and standard brace placement.
* **Comments (Host Language):**
    * Short single-line: `//'comment text'` (or language equivalent like `#`)
    * Short multi-line: `/* 'comment text' */` (use language conventions)
    * Long comments: Use `l<n>` referencing `lit_dict`.
* **Preprocessor Directives (Example: C/C++):** Use dedicated tokens: `#i` (include), `#d` (define), `#?` (ifdef/ifndef), `#:` (else), `#e` (endif), `#p` (pragma), etc. Example: `#i<vector>N#d MAX 100`
* **Decorators (Example: Python):** Prepend the decorator call line with `@`. Example: `@d0 N D d1():P`
* **Accessors/Properties (Example: Python):** Use standard decorator syntax (`@`) and function definitions. Example: `@d0 N D d1(d2): N I+ R d2._d3 N I-`

### 4.4. Escape Hatch: The `L'{...}'` Token

* **Purpose:** To handle host language code constructs that are excessively complex, ambiguous, language-specific beyond standard tokens, or more efficiently represented as a literal block. **This is generally NOT intended for embedded language strings**, which should use `l<n>` or standard string literals.
* **Syntax:** `L'{<original_host_code_substring>}'`.
    * The content between `{` and `}` is treated as **raw host language source code** by the reconstructor.
    * Braces `{` and `}` within the substring MUST be escaped as `\{` and `\}` respectively.
* **Usage Rule:** Use **sparingly** for host language constructs only. Prefer tokenization.

### 4.5. Handling Embedded Languages, DSLs, and Macros

* **Embedded Languages (SQL, HTML, CSS, JS, etc. within Host Strings):**
    * **Rule:** Treat the entire embedded code block as a single **string literal** from the host language's perspective.
    * **Representation:**
        * For short snippets, use standard string literal tokens: `'<embedded code>'`.
        * For significant multi-line blocks, store the Base64 encoded embedded code in `lit_dict` (Level 3 Header) and use the `l<n>` token in the body.
    * **No Internal Tokenization:** CodeQuilt v0.2.0 **does not** attempt to tokenize *within* embedded language strings. Compression focuses on the host language structure.
    * **Size Consideration:** Be aware that large embedded blocks stored via `l<n>` (Base64 encoded) will significantly increase the header size. This is a tradeoff for ensuring complete and accurate reconstruction.
* **Internal DSLs (Fluent Interfaces, Operator Overloading):**
    * **Rule:** Represent using standard CodeQuilt tokens for function/method calls (`.`, `()`), operators (`+`, `|`, etc.), and identifiers (`d<n>`) as defined by the host language syntax. The DSL keywords/methods are simply identifiers mapped in the `dict`.
* **Macros (e.g., Lisp, Rust, Advanced C++):**
    * **Rule (Macro Definition):** Macro definitions, if complex or syntactically unique, should typically be enclosed in the escape hatch `L'{...}'`.
    * **Rule (Macro Invocation):** If macro invocation looks like a standard function call (e.g., `MY_MACRO(arg)`), tokenize it as such (`d0(d1)`). If it uses unique syntax (e.g., `my_macro! arg`), use `L'{...}'` for the invocation statement.

### 4.6. Handling Uncovered Cases / Fallbacks

1.  **Prioritize Host Language Tokenization:** Always attempt to represent host language code using defined tokens first.
2.  **Use `l<n>` for Large Literals/Embedded Code:** Store large strings, multi-line comments, and embedded code blocks in `lit_dict` (Level 3) and reference via `l<n>`.
3.  **Use Escape Hatch `L{}` for Complex Host Syntax:** If a specific host language construct cannot be reasonably tokenized, encapsulate the minimal necessary original source substring within `L'{...}'`.
4.  **Indicate Failure:** If the entire code block is fundamentally unsuited for CodeQuilt (non-textual, etc.), the generating LLM should indicate failure.

## 5. Illustrative Token Reference (Non-Exhaustive)

*Language-specific sets will vary. These are conceptual examples.*

* **Structure:** `N` (Newline), `I+` (Indent Inc), `I-` (Indent Dec), `{`, `}`
* **Keywords:** `D`(def/func), `C`(class), `R`(return), `?`(if), `:`(else/elif), `F`(for), `W`(while), `T`(try), `X`(except), `Y`(finally), `M`(import), `A`(await), `S`(async), `P`(pass/noop)
* **Operators:** `=`, `+`, `-`, `*`, `/`, `%`, `**`(pow), `&`(and/&), `|`(or/|), `~`(not/~), `!`(not/!), `>`, `<`, `G`(>=), `L`(<=), `E`(==), `.`(member access)
* **Delimiters:** `(`, `)`, `[`, `]`, `,`, `;`, `:`(type hint/slice/ternary?)
* **Literals:** `'...'` (string), `t`(True), `f`(False), `n`(None/null), `123`, `3.14`, `b'...'` (bytes)
* **Identifiers:** `d<n>` (e.g., `d0`, `d1`)
* **Literal Refs:** `l<n>` (e.g., `l0`, `l1`)
* **Comments:** `//`, `#`, `/*`, `'''`, `"""` (followed by string literal or `l<n>`)
* **Preprocessor:** `#i`, `#d`, `#?`, `#e`, ...
* **Escape/Misc:** `L'{...}'`, `@`(Decorator prefix)

## 6. Examples

**Example 1: Simple JavaScript Variable** (Same as before)
```javascript
// Original
let count = 0;
count++; // Increment
```
```codequilt
// CodeQuilt (Level 1 Header)
[v:0.2.0;lang:javascript-es2022;dict:[d0=count]]|||L d0=0;N#IncrementN d0++;
```
*(Note: `L` assumed JS `let`. `#` used for comment as per JS potentially.)*

**Example 2: Python Class with Accessor/Property** (Same as before)
```python
# Original
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        """The radius property."""
        return self._radius
```
```codequilt
// CodeQuilt (Level 3 Header for Docstring)
[v:0.2.0;lang:python-3.11;dict:[d0=Circle,d1=__init__,d2=self,d3=radius,d4=_radius,d5=property];lit_dict:[l0=IiJUaGUgcmFkaXVzIHByb3BlcnR5LiI=]]|||C d0:NI+ D d1(d2,d3):NI+ d2.d4=d3 NI- N @d5 N D d3(d2):NI+ l0 N R d2.d4 NI- NI-
```

**Example 3: Python with Embedded SQL (using `l<n>`)**
```python
# Original
import sqlite3

def get_user_email(conn, user_id):
    cursor = conn.cursor()
    query = """
    SELECT email
    FROM users
    WHERE user_id = ? AND active = 1;
    """
    cursor.execute(query, (user_id,))
    result = cursor.fetchone()
    return result[0] if result else None
```
```codequilt
// CodeQuilt (Level 3 Header)
[v:0.2.0;lang:python-3.11;dict:[d0=sqlite3,d1=get_user_email,d2=conn,d3=user_id,d4=cursor,d5=query,d6=execute,d7=result,d8=fetchone];imports:[sqlite3];lit_dict:[l0=CiAgICBTRUxFQ1QgZW1haWwKICAgIEZST00gdXNlcnMKICAgIFdIRVJFIHVzZXJfaWQgPSAiID8gQU5EIGFjdGl2ZSA9IDE7CiAgICAi]]|||M d0 N N D d1(d2,d3):NI+ d4=d2.d4()N d5=l0 N d4.d6(d5,(d3,))N d7=d4.d8()N R d7[0] ? d7 : n NI-
```
*(The multi-line SQL query is Base64 encoded and stored via `l0`.)*

**Example 4: Python with Embedded HTML (using `l<n>`)**
```python
# Original
def generate_html(title, body_content):
    html_template = f"""
<!DOCTYPE html>
<html>
<head><title>{title}</title></head>
<body>
<h1>{title}</h1>
{body_content}
</body>
</html>
"""
    return html_template
```
```codequilt
// CodeQuilt (Level 3 Header)
[v:0.2.0;lang:python-3.11;dict:[d0=generate_html,d1=title,d2=body_content,d3=html_template];lit_dict:[l0=CiYjOTY7Jjk2OyYjOTY7CiYjOTY7ISZkb2N0eXBlIGh0bWw+CiYjOTY7PGh0bWw+CiYjOTY7PGhlYWQ+PHRpdGxlPnt9PC90aXRsZT48L2hlYWQ+CiYjOTY7PGJvZHk+CiYjOTY7PGgxPnt9PC9oMT4KJiM5Njt7fQomIzsKPC9ib2R5PgomIzs8L2h0bWw+CiYjOTY7IiIi']]|||D d0(d1,d2):NI+ d3=f l0 N R d3 NI-
```
*(Note: The example `l0` Base64 is illustrative and represents the f-string content. Reconstruction needs to handle the f-string nature. A more robust approach might place the entire f-string `f"""..."""` into `l0`, requiring the reconstructor to understand it's an f-string.)*
*Self-Correction on Example 4:* A better `l0` would encode the *entire* `f"""..."""` string, or the spec needs refinement on handling f-strings containing `l<n>` references (which is overly complex). Let's assume `l0` holds the template string itself, and the `f` prefix applies. The Base64 in the example needs correction to reflect this. For simplicity, the example shows `f l0`, implying `l0` holds the template content. The Base64 shown is just a placeholder.*

**Example 5: Python Internal DSL (Fluent Interface)**
```python
# Original (assuming a query builder object 'db')
query = db.select('id', 'name').from_table('users').where(status='active')
```
```codequilt
// CodeQuilt (Level 1 Header)
[v:0.2.0;lang:python-3.11;dict:[d0=query,d1=db,d2=select,d3=from_table,d4=where,d5=status]]|||d0=d1.d2('id','name').d3('users').d4(d5='active')
```
*(Shows how DSL methods are treated as standard chained method calls.)*

## 7. Notes on Compression Standards & Symbol Mapping

(Same as v0.2.0 draft - standard compression works differently, CodeQuilt uses pre-defined text IDs, Base64 for robustness in `lit_dict`)

While standard compression algorithms like Huffman coding or Lempel-Ziv (LZW) use dictionary mapping to achieve high compression ratios (used in gzip, zip, etc.), they typically operate on byte streams and generate binary output. They build dictionaries dynamically based on input frequency.

CodeQuilt uses a conceptually similar dictionary approach (`dict`, `lit_dict`) but with key differences:
* **Pre-defined Dictionary (Per-Generation):** The dictionary is explicitly defined in the header *before* the body is processed.
* **Text-Based IDs:** Uses simple alphanumeric IDs (`d<n>`, `l<n>`) suitable for direct generation and inclusion in a text stream by an LLM.
* **No Direct UTF Symbol Mapping:** CodeQuilt v0.2.0 does not map tokens directly to extended UTF symbols. While potentially offering higher density, this adds complexity for LLM generation and font/display compatibility. Using short ASCII sequences is deemed more practical currently.
* **Base64 for Robustness:** Base64 is used in `lit_dict` to safely embed arbitrary literal content within the text-based header, accepting the slight size overhead (~33%) compared to raw binary for the sake of parse safety.

## 8. Reconstruction Notes

* A dedicated CodeQuilt Reconstructor tool or LLM prompt is required.
* The reconstructor MUST parse the header first to understand version, language, dictionaries (`dict`, `lit_dict`), and options. It must handle Base64 decoding for `lit_dict` entries.
* It MUST map body tokens (`d<n>`, `l<n>`, keywords, operators) back to their source code equivalents based on the `lang` context.
* It MUST correctly handle structure tokens (`N`, `I+`, `I-`, `{`, `}`) to rebuild indentation and block structure according to host language rules.
* It MUST process `L{...}` blocks by extracting the content and inserting it verbatim (after handling escaped braces `\{`, `\}`).
* It MUST correctly substitute `l<n>` tokens with the corresponding decoded literal from `lit_dict`.
* Running a language-specific code formatter (e.g., Black, Prettier, clang-format) after reconstruction is highly recommended for consistent styling.
* Checksum verification (`chk`) should be performed if the field is present.
