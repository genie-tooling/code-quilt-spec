# CodeQuilt Specification v0.2.1

**Version:** 0.2.1
**Date:** 2025-04-06 *(Based on EBNF date and context)*
**Status:** Draft (Integrating Formal Syntax)

## 1. Introduction & Purpose

CodeQuilt is a specification for representing source code in a highly compressed, text-based format. It is designed to be generated by Large Language Models (LLMs) *prior* to generating the full source code. Its primary purpose is to serve as a robust "blueprint" or "manifest" that is less likely to be truncated during generation and can be used to reconstruct the original intended code accurately.

This specification defines the format structure, encoding rules incorporating formal EBNF definitions, canonical handling for common and complex language features, fallback mechanisms, and considerations for embedded languages.

## 2. Overall Format

A CodeQuilt string consists of two parts separated by the delimiter `|||`:

```
[Header]|||Body
```

* **Header:** Contains metadata, including version, language, identifier/literal mappings, and options. Enclosed in square brackets `[]`.
* **Body:** Contains the compressed sequence of tokens representing the code structure and logic.

Formally (EBNF):
`codequilt-string ::= "[" header "]" "|||" body-tokens`

## 3. Header Specification (`[Header]`)

The header uses key-value pairs separated by semicolons `;`. Keys are short mnemonics. No whitespace should exist around keys, values, `:`, or `;` unless part of a literal value (which is strongly discouraged; use `lit_dict`).

Formally (EBNF):
`header ::= header-field (";" header-field)*`

### 3.1. Header Verbosity Levels

CodeQuilt v0.2.1 defines three distinct header verbosity levels to balance compression with information richness:

* **Level 1 (Shortest):** Minimal required information for basic reconstruction.
* **Level 2 (Medium):** Includes Level 1 plus recommended optional fields for better context and verification.
* **Level 3 (Longest):** Includes Level 2 plus mappings for long literals/comments/embedded code via `lit_dict`. Recommended for sources with significant multi-line strings, comments, or embedded code.

### 3.2. Header Fields

Fields are categorized by the minimum verbosity level at which they MUST appear. Higher levels include all fields from lower levels. The EBNF defines the valid `header-field` types.

**Level 1 Fields (Required Minimum):**

* `v:<version>`: **(Required)** CodeQuilt specification version.
    * **Format (EBNF):** `version-field ::= "v:" version-string`
    * **Where:** `version-string ::= digit+ "." digit+ "." digit+` (e.g., `0.2.1`)
    * Example: `v:0.2.1`
* `lang:<language>[-version]`: **(Required)** Target *host* language and optional version. Crucial for reconstruction context.
    * **Format (EBNF):** `language-field ::= "lang:" language-id ("-" language-version)?`
    * **Where:**
        * `language-id ::= identifier` (e.g., `python`, `javascript`)
        * `language-version ::= language-version-char+` (e.g., `3.11`, `es2022`)
        * `language-version-char ::= letter | digit | "+" | "."`
    * Example: `lang:python-3.11`, `lang:javascript-es2022`, `lang:c++17`
* `dict:[d<n>=identifier,...]`: **(Required)** Identifier Dictionary. Maps compact IDs (`d0`, `d1`, ...) to source code identifiers in the *host* language. IDs MUST be sequential starting from `d0`.
    * **Format (EBNF):** `dict-field ::= "dict:" "[" (dict-entry ("," dict-entry)*)? "]"`
    * **Where:** `dict-entry ::= "d" digit+ "=" identifier`
    * Example: `dict:[d0=myVar,d1=calculateValue]`

**Level 2 Fields (Recommended):**

* *All Level 1 Fields*
* `imports:[path1,path2 as alias,...]`: **(Optional but Recommended)** List of modules/libraries imported. Aids context.
    * **Format (EBNF):** `imports-field ::= "imports:" "[" (import-item ("," import-item)*)? "]"`
    * **Where:**
        * `import-item ::= import-path (" " "as" " " identifier)?`
        * `import-path ::= safe-header-value-char+` (See `safe-header-value-char` below)
    * Example: `imports:[os,numpy as np]`
* `opts:[opt1,opt2=value,...]`: **(Optional)** Reconstruction options/flags.
    * **Format (EBNF):** `options-field ::= "opts:" "[" (option ("," option)*)? "]"`
    * **Where:**
        * `option ::= identifier ("=" option-value)?`
        * `option-value ::= safe-header-value-char+` (See `safe-header-value-char` below)
    * Common Options: `strict`, `fmt=on/off`, `enc=<encoding>`
    * Example: `opts:[strict,fmt=on]`
* `chk:<algo>-<hash>`: **(Optional but Recommended)** Checksum of the intended *final* code.
    * **Format (EBNF):** `checksum-field ::= "chk:" checksum-algo "-" checksum-hash`
    * **Where:**
        * `checksum-algo ::= identifier` (e.g., `sha256`)
        * `checksum-hash ::= hex-digit+`
        * `hex-digit ::= digit | "a".."f" | "A".."F"`
    * Example: `chk:sha256-a1b2c3d4e5f6...`

**Level 3 Fields (Maximum Verbosity):**

* *All Level 2 Fields*
* `lit_dict:[l<n>=base64(literal),...]`: **(Optional, Level 3 Specific)** Literal Dictionary. Maps compact IDs (`l0`, `l1`, ...) to long string literals, multi-line comments, docstrings, or `L{}` escape hatch content. **Primary mechanism for storing embedded code (SQL, HTML, etc.)**. Literals MUST be Base64 encoded. IDs MUST be sequential starting from `l0`.
    * **Format (EBNF):** `lit-dict-field ::= "lit_dict:" "[" (lit-dict-entry ("," lit-dict-entry)*)? "]"`
    * **Where:**
        * `lit-dict-entry ::= "l" digit+ "=" base64-string`
        * `base64-string ::= (base64-char)* ("=" "="?)?`
        * `base64-char ::= letter | digit | "+" | "/"`
    * Example: `lit_dict:[l0=VGhpcyBpcyBhIGRvY3N0cmluZy4=,l1=U0VMRUNUICogRlJPTSB1c2VycyBXSEVSRSBpZCA9IDQyOw==]`

**Header Character Constraints:**

* The EBNF defines `safe-header-value-char ::= letter | digit | "_" | "." | "/" | "+" | ":" | "-" | "="`. This represents printable ASCII characters generally safe for use in values like `import-path` or `option-value`, excluding structural characters (`[`, `]`, `;`, `,`) and whitespace *around* delimiters.
* Using complex characters or whitespace within header values directly is strongly discouraged. Use the `lit_dict` field with Base64 encoding for robustness.

### 3.3. Header Examples (Updated Version)

**Level 1 (Shortest):**
```
[v:0.2.1;lang:python-3.11;dict:[d0=my_list,d1=append]]
```

**Level 2 (Medium):**
```
[v:0.2.1;lang:python-3.11;dict:[d0=data,d1=process_data,d2=pd,d3=read_csv];imports:[pandas as pd];opts:[strict];chk:sha256-abcdef12345]
```

**Level 3 (Longest - including Base64'd SQL query):**
```
[v:0.2.1;lang:python-3.11;dict:[d0=db_conn,d1=cursor,d2=execute,d3=user_id];imports:[sqlite3];opts:[strict];chk:sha256-abcdef12345;lit_dict:[l0=IlNFTEVDVCBuYW1lLCBlbWFpbCBGUk9NIHBlb3BsZSBXSEVSRSBpZCA9ID8i]]
```

## 4. Body Specification (`Body`)

The body is a continuous string of tokens representing the code.

Formally (EBNF):
`body-tokens ::= (token)*`
`token ::= structure-token | keyword-token | operator-token | delimiter-token | literal-token | identifier-ref | literal-ref | comment-token | preprocessor-token | escape-hatch-token | decorator-prefix`
*(Note: The specific set of `keyword-token`, `operator-token`, `delimiter-token`, `preprocessor-token` depends on the `lang` header field).*

### 4.1. Token Philosophy

* **Maximally Dense:** Use single non-alphanumeric characters or short mnemonics.
* **Contextual:** Meaning depends on the `lang` specified in the header.
* **No Redundancy:** Omit characters reconstructible from context (e.g., most whitespace).

### 4.2. Whitespace Handling

* Whitespace characters (spaces, tabs, line breaks) within the CodeQuilt **Body** string are **IGNORED**, except when inside a literal string token's content (defined via `string-literal` in EBNF).
* Code structure (newlines, indentation) MUST be represented using explicit `structure-token`s.

### 4.3. Canonical Handling of Common & Complex Cases

* **Identifiers:** Represented by `d<n>` tokens.
    * **Format (EBNF):** `identifier-ref ::= "d" digit+`
* **Literals:**
    * Short host language literals directly embedded.
        * **Format (EBNF):** `literal-token ::= string-literal | number-literal | boolean-literal | null-literal | bytes-literal`
        * `string-literal ::= "'" (single-quoted-string-char)* "'" | '"' (double-quoted-string-char)* '"'`
            * Characters within strings follow EBNF rules: `single-quoted-string-char`, `double-quoted-string-char`, including `escape-sequence ::= "\\" ( "'" | '"' | "\\" | "n" | "t" | "r" | "b" | "f" | unicode-escape )`.
        * `number-literal ::= ("+" | "-")? digit+ ("." digit+)?` (Simplified)
        * `boolean-literal ::= "t" | "f"`
        * `null-literal ::= "n"`
        * `bytes-literal ::= "b" string-literal`
    * Long/Complex literals (docstrings, multi-line comments, **embedded code strings**): Store Base64 encoded content in `lit_dict` (Level 3 Header) and reference with `l<n>` token.
        * **Format (EBNF):** `literal-ref ::= "l" digit+`
* **Structure:** Use explicit tokens.
    * **Format (EBNF):** `structure-token ::= "N" | "I+" | "I-" | "{" | "}"`
    * `N`: Newline.
    * `I+`: Increase indentation level for the *next* line.
    * `I-`: Decrease indentation level for the *next* line.
    * `{`, `}`: Brace-based block start/end (implying indentation changes in relevant languages).
* **Comments (Host Language):**
    * Short comments represented using comment tokens. The comment *content* follows string literal rules.
        * **Format (EBNF):** `comment-token ::= ("//" | "#") string-literal | "/*" string-literal "*/"`
    * Long comments: Use `l<n>` referencing `lit_dict`.
* **Preprocessor Directives (Example: C/C++):** Use dedicated tokens.
    * **Format (EBNF Examples):** `preprocessor-token ::= "#i" | "#d" | "#?" | "#e" | ...` (followed by language-specific arguments).
    * Example: `#i<vector>N#d MAX 100`
* **Decorators (Example: Python):** Prepend the decorator call line with `@`.
    * **Format (EBNF):** `decorator-prefix ::= "@"`
    * Example: `@d0 N D d1():P`
* **Accessors/Properties (Example: Python):** Use standard decorator syntax (`@`) and function definitions.

### 4.4. Escape Hatch: The `L'{...}'` Token

* **Purpose:** To handle host language constructs that are excessively complex, ambiguous, or more efficiently represented as a literal block. **Generally NOT for embedded language strings** (use `l<n>` or string literals).
* **Syntax (EBNF):** `escape-hatch-token ::= "L" "'{" raw-host-code "}'"`
    * `raw-host-code ::= (raw-host-char)*`
    * `raw-host-char ::= escaped-brace | non-brace-non-backslash-char`
    * `escaped-brace ::= "\\" ("{" | "}")`
    * `non-brace-non-backslash-char ::= (* Any character that is not "{" or "}" or "\" *)`
* **Usage Rule:** Use **sparingly** for host language constructs only.

### 4.5. Handling Embedded Languages, DSLs, and Macros

* **Embedded Languages (SQL, HTML, CSS, JS, etc. within Host Strings):**
    * **Rule:** Treat the entire embedded code block as a single **string literal** (`string-literal` or `bytes-literal`) from the host language's perspective.
    * **Representation:**
        * Short snippets: Use standard literal tokens (e.g., `'<embedded code>'`).
        * Significant blocks: Store Base64 encoded in `lit_dict` (Level 3 Header) and use `l<n>` (`literal-ref`).
    * **No Internal Tokenization:** CodeQuilt **does not** tokenize *within* embedded language strings.
* **Internal DSLs (Fluent Interfaces, Operator Overloading):**
    * **Rule:** Represent using standard CodeQuilt tokens for function/method calls (`.`, `()`), operators (`+`, `|`), and identifiers (`d<n>`) as defined by host language syntax.
* **Macros (e.g., Lisp, Rust, Advanced C++):**
    * **Rule (Definition):** Typically enclose complex/unique macro definitions in `L'{...}'` (`escape-hatch-token`).
    * **Rule (Invocation):** If invocation looks standard (e.g., `d0(d1)`), tokenize as such. If unique syntax, use `L'{...}'`.

### 4.6. Handling Uncovered Cases / Fallbacks

1.  Prioritize Host Language Tokenization using defined `token` types.
2.  Use `l<n>` (`literal-ref`) for Large Literals/Embedded Code via `lit_dict`.
3.  Use Escape Hatch `L'{...}'` (`escape-hatch-token`) for Complex Host Syntax.
4.  Indicate failure if code is fundamentally unsuited (e.g., non-textual).

## 5. Illustrative Token Reference (Non-Exhaustive)

*Language-specific sets (`keyword-token`, `operator-token`, etc.) will vary.*

* **Structure (`structure-token`):** `N` (Newline), `I+` (Indent Inc), `I-` (Indent Dec), `{`, `}`
* **Keywords (`keyword-token` examples):** `D`(def/func), `C`(class), `R`(return), `?`(if), `:`(else/elif), `F`(for), `W`(while), `T`(try), `X`(except), `Y`(finally), `M`(import), `A`(await), `S`(async), `P`(pass/noop)
* **Operators (`operator-token` examples):** `=`, `+`, `-`, `*`, `/`, `%`, `**`(pow), `&`(and/&), `|`(or/|), `~`(not/~), `!`(not/!), `>`, `<`, `G`(>=), `L`(<=), `E`(==), `.`(member access)
* **Delimiters (`delimiter-token` examples):** `(`, `)`, `[`, `]`, `,`, `;`, `:`(type hint/slice/ternary?)
* **Literals (`literal-token` examples):** `'...'` (string), `t`(True), `f`(False), `n`(None/null), `123`, `3.14`, `b'...'` (bytes)
* **Identifiers (`identifier-ref`):** `d<n>` (e.g., `d0`, `d1`)
* **Literal Refs (`literal-ref`):** `l<n>` (e.g., `l0`, `l1`)
* **Comments (`comment-token` initiator examples):** `//`, `#`, `/*` (followed by `string-literal` or referenced by `l<n>`)
* **Preprocessor (`preprocessor-token` examples):** `#i`, `#d`, `#?`, `#e`, ...
* **Escape/Misc (`escape-hatch-token`, `decorator-prefix`):** `L'{...}'`, `@`

## 6. Examples (Using v0.2.1 Headers)

**Example 1: Simple JavaScript Variable**
```javascript
// Original
let count = 0;
count++; // Increment
```
```codequilt
// CodeQuilt (Level 1 Header)
[v:0.2.1;lang:javascript-es2022;dict:[d0=count]]|||L d0=0;N#IncrementN d0++;
```
*(Assuming JS `let` maps to `L`, `#` used for comment based on EBNF possibility)*

**Example 2: Python Class with Accessor/Property**
```python
# Original
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        """The radius property."""
        return self._radius
```
```codequilt
// CodeQuilt (Level 3 Header for Docstring)
[v:0.2.1;lang:python-3.11;dict:[d0=Circle,d1=__init__,d2=self,d3=radius,d4=_radius,d5=property];lit_dict:[l0=IiJUaGUgcmFkaXVzIHByb3BlcnR5LiI=]]|||C d0:NI+ D d1(d2,d3):NI+ d2.d4=d3 NI- N @d5 N D d3(d2):NI+ l0 N R d2.d4 NI- NI-
```

**Example 3: Python with Embedded SQL (using `l<n>`)**
```python
# Original
import sqlite3

def get_user_email(conn, user_id):
    cursor = conn.cursor()
    query = """
    SELECT email
    FROM users
    WHERE user_id = ? AND active = 1;
    """
    cursor.execute(query, (user_id,))
    result = cursor.fetchone()
    return result[0] if result else None
```
```codequilt
// CodeQuilt (Level 3 Header)
[v:0.2.1;lang:python-3.11;dict:[d0=sqlite3,d1=get_user_email,d2=conn,d3=user_id,d4=cursor,d5=query,d6=execute,d7=result,d8=fetchone];imports:[sqlite3];lit_dict:[l0=CiAgICBTRUxFQ1QgZW1haWwKICAgIEZST00gdXNlcnMKICAgIFdIRVJFIHVzZXJfaWQgPSAiID8gQU5EIGFjdGl2ZSA9IDE7CiAgICAi]]|||M d0 N N D d1(d2,d3):NI+ d4=d2.d4()N d5=l0 N d4.d6(d5,(d3,))N d7=d4.d8()N R d7[0] ? d7 : n NI-
```

*(Remaining examples 4 & 5 from original spec follow similar logic)*

## 7. Notes on Compression Standards & Symbol Mapping

(Same as v0.2.0 draft - standard compression works differently, CodeQuilt uses pre-defined text IDs, Base64 for robustness in `lit_dict`)

CodeQuilt uses a dictionary approach (`dict`, `lit_dict`) similar in concept to standard compression algorithms but differs:
* **Pre-defined Dictionary (Per-Generation):** Defined explicitly in the header.
* **Text-Based IDs:** Uses simple alphanumeric IDs (`d<n>`, `l<n>`).
* **No Direct UTF Symbol Mapping:** Avoids complexity of mapping tokens to extended UTF symbols.
* **Base64 for Robustness:** Used in `lit_dict` to safely embed arbitrary literal content, accepting size overhead (~33%) for parse safety.

## 8. Reconstruction Notes

* A dedicated CodeQuilt Reconstructor tool or LLM prompt is required.
* Must parse the header according to the formal structure (EBNF) to understand version, language, dictionaries (`dict`, `lit_dict`), options. Must handle Base64 decoding for `lit_dict`.
* Must map body tokens (`d<n>`, `l<n>`, keywords, operators, structure tokens, etc.) back to source code equivalents based on `lang` context.
* Must correctly handle `structure-token`s (`N`, `I+`, `I-`, `{`, `}`) to rebuild structure.
* Must process `escape-hatch-token` (`L{...}`) by extracting content verbatim (handling `escaped-brace`).
* Must substitute `l<n>` (`literal-ref`) with decoded literals.
* Post-reconstruction formatting is recommended. Checksum verification (`chk`) if present.
